# Spring Intro \_ JPA 설치 및 실행

## Spring

- Spring by VMware Tanzu
- VM : 가상머신
- 스프링은 VMware가 바탕임

- microservices
- reactive
- cloud
- web apps
- serverless
- event driven
- batch

### 서버

- 또 하나의 PC??
- 제공자
- PC의 데이터를 가져갈 수 있게 열어주면 서버임 (장비를 오픈 하면 서버임)
  - 포트 : 들어오는 입구 (포트 번호 : 8080, 3000, … )
- 포트를 열어 놓으면 그거를 타고 들어 올 수 있음

  - 그 문을 통해서 들어오면 거기에 열어둔것만 볼 수 있게 권한설정
  - +데이터 양 증가 → 서버관리

- Java → 서버 개발에 왜 많이 사용하는가?? 왜 우리나라는??
- 대중적이니깐 : 개발자 = Java
- c를 사용해서 만든 대표적인 언어가 Java
- 왜 객체지향으로 만들어야 했는가?
- 왜 프로그램이 발전하는가?
  - 1. 군사목적 → 과거 빠른 통신 위해
  - 2. 유흥 → 게임산업 →블럭깨기→→ 멀티 플레이 / 롤 플레이 (인스턴스 개념 도입됨)
    - ex) 마인크래프트 : java ⇒ 스웨덴에서 만들어서 MS가 삼

## Spring Data JPA (Java Persistence Api)

[참고링크](https://spring.io/projects/spring-data-jpa)

- java는 객체 중심
- DB는 표 중심

1. 객체랑 표가 안맞음

2. mybatis → sql → sql을 자동으로 써주는게 있으면 좋겠다!! → 하이버네이트 (게빈킹!!)

### 하이버네이트

- 자바 언어를 위한 객체 관계 매핑 프레임워크
- 클래스가 그대로 DB로 쓸 수 있으면 좋겠다
- Hibernate ORM → JPA
- jar : 자르 / war : 와르

---

## 01.스프링 부트란?

스프링 프레임워크는 자바 기반의 애플리케이션 프레임워크로 엔터프라이즈급 애플리케이션을 개발하기 위한 다양한 기능을 제공함
스프링은 목적에 따라 다양한 프로젝트를 제공하는데 그중 하나가 스프링 부트임

### 1.1스프링 프레임워크

- 자바에서 가장 많이 사용하는 프레임워크임
- 자바로 애플리케이션을 개발하는데 필요한 기능을 제공하고 쉽게 사용하도록 돕는 도구임
- "애플리케이션 개발에 필요한 기반을 제공해서 개발자가 비즈니스 로직 구현에만 집중할 수 있게끔 하는것"

#### 1.1.1 제어역전(IoC)

- 일반적인 자바 개발의 경우 사용하려는 객체를 선언하고 해당 객체의 의존성을 생성한 후 객체에서 제공하는 기능을 사용함

  - 객체를 생성하고 사용하는 일련의 작업을 개발자가 직접 제어하는 구조임

- 하지만 제어 역전(Inversion of Control)을 특징으로 하는 스프링은 기존 자바 개발 방식과 다르게 동작함
- IoC를 적용한 환경에서는 사용할 객체를 직접 생성하지 않고 객체의 생명주기 관리를 외부에 위임함
  - 외부 : 스프링 컨테이너 or IoC 컨테이너를 의미함
- 객체의 관리를 컨테이너에 맡겨 제어권이 넘어간 것을 제어 역전이라고 부름
- 제어 역전을 통해 의존성 주입(DI), 관점 지향 프로그래밍(AOP) 등이 가능해짐

#### 1.1.2 의존성 주입(DI)

- Dpendency Injection
- 제어 역전의 방법 중 하나로 사용할 객체를 직접 생성하지 않고 외부 컨테이너가 생성한 객체를 주입받아 사용하는 방식을 의미함

  - 생성자를 통한 의존성 주입
  - 필드 객체 선언을 통한 의존성 주입
  - setter 메서드를 통한 의존성 주입

- 다른 방식과는 다르게 생성자를 통해 의존성을 주입받는 방식은 래퍼런스 객체 없이는 객체를 초기화할 수 없게 설계할 수 있음
- @Autowired 라는 어노테이션을 통해 의존성을 주입할 수 있음

#### 1.1.3 관점 지향 프로그래밍(AOP)

- Aspect-Oriented Programming
- AOP는 OOP를 더욱 잘 사용하도록 돕는 개념으로 보면 됨
- AOP는 관점을 기준으로 묶어 개발하는 방식을 의미함
- 관점(aspect)이란 어떤 기능을 구현할 때 그 기능을 '핵심 기능'과 '부가 기능'으로 구분해 각각을 하나의 관점으로 보는 것을 의미함
  - '핵심기능' : 비즈니스 로직을 구현하는 과정에서 비즈니스 로직이 처리하려는 목적 기능
  - '부가기능' : 핵심 기능이 어떤 기능인지에 무관하게 로직이 수행되기 전 또는 후에 수행되기만 하면 됨
- 여러 비즈니스 로직에서 반복되는 부가 기능을 하나의 공통 로직으로 처리하도록 모듈화해 삽입하는 방식을 AOP라고 함

- 스프링은 디자인 패턴 중 하나인 프락시 패턴을 통해 AOP 기능을 제공하고 있음

#### 1.1.4 스프링 프레임워크의 다양한 모듈

- 기능별로 구분된 약 20여 개의 모듈로 구성돼 있음
- 경량 컨테이너 설계

### 1.2 스프링 프레임워크 vs 스프링 부트

- 스프링에서 하이버네이트를 사용함
  - 설정이 복잡함
- 스프링 부트를 사용하면 개발이 쉬워짐

> > > > 스프링이 가진 특징 ->

#### 1.2.1 의존성 관리

- 'spring-boot-starter' 의존성을 제공함

#### 1.2.2 자동 설정

- 스프링 프레임워크를 사용하기 위한 자동 설정을 지원함
- 애플리케이션을 개발하는데 필요한 의존성을 추가하면 프레임워크가 이를 자동으로 관리해줌

- @SpringBootApplication 어노테이션
  - @SpringBootConfiguration
  - @EnableAutoConfiguration
  - @ComponentScan

참고==

- @Component 시리즈 어노테이션의 대표적인 예
  - @Controller
  - @RestController
  - @Service
  - @Repository
  - @Configuration

#### 1.2.3 내장 WAS

- 내장 WAS라니!!!!!!

#### 1.2.4 모니터링

- 시스템이 사용하는 메모리, 스레드, 세션 등의 주요 요소들을 모니터링해야 함
- 스프링 부트 액추에이터 (Spring Boot Actucator)라는 자체 모니터링 도구가 있음

### 2.3 레이어드 아키텍처

- 애플리케이션의 컴포넌트를 유사 관심사를 기준으로 레이어로 묶어 수평적으로 구성한 구조를 의미함

- 프레젠테이션 계층

  - 애플리케이션의 최상단 계층으로, 클라이언트의 요청을 해석하고 응답하는 역할임
  - UI나 API를 제공함
  - 별도의 비즈니스 로직을 포함하고 있지 않으므로 비즈니스 계층으로 요청을 위임하고 받은 결과를 응답하는 역할만 수행함

- 비즈니스 계층

  - 애플리케이션이 제공하는 기능을 정의하고 세부 작업을 수행하는 도메인 객체를 통해 업무를 위임하는 역할을 수행함
  - DDD 기반의 아키텍처에서는 비즈니스 로직에 도메인이 포함되기도 하고 별도로 도메인 계층을 두기도 함

- 데이터 접근 계층

  - 데이터베이스에 접근하는 일련의 작업을 수행함

- 각 레이어는 가장 가까운 하위 레이어의 의존성을 주입받음
- 각 레이어는 관심사에 따라 묶여 있으며, 다른 레이어의 역할을 침범하지 않음

  - 각 컴포넌트의 역할이 명확하므로 코드의 가독성과 기능 구현에 유리함
  - 코드의 확장성도 좋아짐

- 각 레이어가 독립적으로 작성되면 다른 레이어와의 의존성을 낮춰 단위 테스트에 용이함

##### spring mvc

- Model - View - Controller 구조
- View와 Controller는 프레젠테이션 계층 영역임
- Model은 비즈니스와 데이터 접근 계층의 영역으로 구분할 수 있음

- DAO (Spring Data JPA에서는 Repository)를 데이터 접근 계층에 배치해 도메인을 관리함

- 프레젠테이션 계층

  - 상황에 따라 유저 인터페이스 계층이라 함
  - 클라이언트와의 접점이 됨!!!
  - 클라이언트로부터 데이터와 함께 요청을 받고 처리 결과를 응답으로 전달하는 역할임

- 비즈니스 계층

  - 상황에 따라 서비스 계층이라고도 함
  - 핵심 비즈니스 로직을 구현하는 영역임!!!!!
  - 트랜잭션 처리나 유효성 검사 등의 작업도 수행함

- 데이터 접근 계층

  - 상황에 따라 영속(Persistence) 계층이라고도 함
  - 데이터베이스에 접근해야 하는 작업을 수행함
  - DAO 역할을 리포지토리가 수행하기 때문에 리포지토리로 대체할 수 있음

- 비즈니스 로직은 도메인 계층에서 담당하는 것이 일반적임
- 스프링에서 JPA를 사용하면 @Entity를 정의한 클래스가 도메인 객체가 되며 이곳에서 비즈니스 로직을 설계하면 좋음

### 2.4 디자인 패턴

### 2.5 REST API

- 애플리케이션 인터페이스
- 클라이언트는 서버에 접근하고 자원을 조작할 수 있음

#### 2.5.1 REST 란?

- 분산 하이퍼미디어 시스템 아키텍처의 한 형식임
- 주고받는 자원에 이름을 규정하고 URI에 명시해 HTTP 메서드 (GET, POST, PUT, DELETE)를 통해 해당 자원의 상태를 주고받는 것을 의미함

#### 2.5.2 REST API란?

- API : 애플리케이션에서 제공하는 인터페이스
  - API를 통해 서버 또는 프로그램 사이를 연결할 수 있음
- REST API는 REST 아키텍처를 따르는 시스템/애플리케이션 인터페이스라고 볼 수 있음

### 5.2.1 @RequestMapping으로 구현하기

- @RequestMapping 어노테이션을 별다른 설정 없이 선언하면 HTTP의 모든 요청을 받음
- 그러나 GET 형식의 요청만 받기 위해서는 오노테이션에 별도 설정이 필요함

  - method = RequestMetod.GET

- @GetMapping
- @PostMapping
- @PutMapping
- @DeleteMapping

##### URI와 URL의 차이

- URL : 우리가 흔히 말하는 웹 주소를 의마하며 리소스가 어디에 있는지 알려주기 위한 경로를 의미함
- URI : 특정 리소스를 식별할 수 있는 식별자를 의미함

- 웹에서는 URL을 통해 리소스가 어느 서버에 위치해 있는지 알 수 있으며 그 서버에 접근해서 리소스에 접근하기 위해서 대부분 URI가 필요함

#### 5.2.5 DTO 객체를 활용한 GET 메서드 구현

DTO란?

- Data Transfer Object의 약자
- 다른 레이어 간의 데이터 교환에 활용됨
- 각 클래스 및 인터페이스를 호출하면서 전달하는 매개변수로 사용되는 데이터 객체임

- DTO는 데이터를 교환하는 용도로만 사용하는 객체이기 때문에 DTO에는 별도의 로직이 포함되지 않음

##### DTO와 VO

- 역할과 사용법에서 차이가 있음

VO

- 데이터 그 자체로 의미가 있는 객체를 의미함
  DTO
- 데이터 전송을 위해 사용되는 데이터 컨테이너

### 5.3 POST API 만들기

- 웹 애플리케이션을 통해 데이터베이스 등의 저장소에 리소스를 저장할 때 사용되는 API임
- 저장하고자 하는 리로스나 값을 HTTP 바디(Body)에 담아 서버에 전달함
- URI 가 GET API에 비해 간단함

### 5.6 REST API 명세를 문서화하는 방법 - Swagger

- API를 개발하면 명세를 관리해야함
- 명세란 해당 API가 어떤 로직을 수행하는지 설명하고 이 로직을 수행하기 위해 어떤 값을 요청하며, 이에 따른 응답값으로는 무엇을 받을 수 있는지를 정리한 자료임

- API는 개발 과정에서 계속 변경되므로 작성한 명세 문서도 주기적인 업데이트가 필요함

### 5.7 로깅 라이브러리 - Logback

- 로깅이란 애플리케이션이 동작하는 동안 시스템의 상태나 동작 정보를 시간순으로 기록하는 것을 의미함
- 로깅은 개발 영역중 '비기능 요구사항'에 속함
- 사용자나 고객이 필요한 기능은 아니라는 의미임

  - 하지만 로깅은 디버깅하거나 개발 이후 발생한 문제를 해결할 때 원인을 분석하는 데 꼭 필요한 요소임

- 자바 진영에서 가장 많이 사용되는 로깅 프레임워크는 Logback임

  - log4j 이후에 출시된 로깅 프레임워크로서 slf4j를 기반으로 구현됐으며, 과거에 사용되던 log4j에 비해 성능이 좋음

- TRACE, DEBUG, INFO, WARN, ERROR

---

## 06 데이터베이스 연동

- 애플리케이션은 데이터(리소스)를 주고받는 것이 주 목적임

### 6.2 ORM

- Object Relational Mapping
- 객체 관계 매핑
- 자바와 같은 객체지향 언어에서 의미하는 객체와 RDB의 테이블을 자동으로 매핑하는 방법임
  - 객체는 클래스를 의미함
  - 클래스는 데이터베이스의 테이블과 매핑하기 위해 만들어진 것이 아니기 때문에 RDB 테이블과 어쩔 수 없는 불일치가 존재함
- 이 둘의 불일치와 제약사항을 해결하는 역할임
- orm을 이용하면 쿼리문 작성이 아닌 코드(메서드)로 데이터를 조작할 수 있음

ORM 장점

- ORM을 사용하면서 데이터베이스 쿼리를 객체지향적으로 조작할 수 있음
- 재사용 및 유지보수가 편리함
- 데이터베이스에 대한 종속성이 줄어듬

ORM 단점

- ORM 만으로 온전한 서비스를 구현하기에는 한계가 있음
- 애플리케이션의 객체 관점과 데이터베이스의 관계 관점의 불일치가 발생함

### 6.3 JPA

- Java Persistence API
- 자바 진영의 ORM 기술 표준으로 채택된 인터페이스 모음임
- ORM이 큰 개념이라면 JPA는 더 구체화된 스펙을 포함됨
- JPA 또한 실제 동작하는 것이 아니고 어떻게 동작해야 하는지 메커니즘을 정리한 표준 명세로 생각하면 됨
  - JPA의 역할이 ORM이라고 봐도됨

JPA 기반의 구현체 대표 세가지

- 하이버네이트 (가장 많이 사용되는 구현체)
- 이클립스 링크
- 데이터 뉴클리어스

### 6.4 하이버네이트

- Spring Data JPA : 하이버네이트의 기능을 더욱 편하게 사용하도록 모듈화함
  - JPA를 편리하게 사용할 수 있도록 지원하는 스프링 하위 프로젝트 중 하나임
  - CRUD 처리에 필요한 인터페이스르 제공

### 6.5 영속성 컨텍스트

- Persistence Context
- 애플리케이션과 데이터베이스 사이에서 엔티티와 레코드의 괴리를 해소하는 기능과 객체를 보관하는 기능을 수행함
- 엔티티 객체가 영속성 컨텍스트에 들어와 JPA의 관리 대상이 되는 시점부터는 해당 객체를 영속 객체라고 부름

### 6.7 엔티티 설계

- JPA에서 엔티티는 데이터베이스의 테이블에 대응하는 클래스임
- 엔티티에는 데이터베이스에 쓰일 테이블과 칼럼을 정의함
- 엔티티에 어노테이션을 사용하면 테이블 간의 연관관계를 정의할 수 있음

- @Entity
- getter/setter 메서드

#### 6.7.1 엔티티 관련 기본 어노테이션

##### @Entity

- 해당 클래스가 엔티티임을 명시하기 위한 어노테이션임
- 클래스 자체는 테이블과 일대일로 매칭되며, 해당 클래스의 인스턴스는 매핑되는 테이블에서 하나의 레코드를 의미함

##### @Table

- 클래스의 이름과 테이블의 이름을 다르게 지정해야 하는 경우 사용
- @Table 어노테이션을 명시하지 않으면 테이블의 이름과 클래스의 이름이 동일하다는 의미임
  - 사용 예시 : @Table(name = 값)

##### @Id

- 테이블의 기본값 역할로 사용됨
- 모든 엔티티는 @Id 어노테이션이 필요함

##### @GeneratedValue

- 일반적으로 @Id 어노테이션과 함께 사용됨
- 해당 필드의 값을 어떤 방식으로 자동으로 생성할지 결정할 때 사용함

  - GeneratedValue를 사용하지 않는 방식(직접 할당)
  - AUTO
  - IDENTITY
  - SEQUENCE
  - TABLE

##### @Column

- 엔티티 클래스의 필드는 자동으로 테이블 컬럼으로 매핑됨
- @Column 어노테이션은 필드에 몇가지 설정을 더할 때 사용함
  - name
  - nullable
  - length
  - unique

##### @Transient

- 엔티티 클래스에는 선언돼 있는 필드지만 데이터베이스에서는 필요 없을 경우 이 어노테이션을 사용해 데이터베이스에서 이용하지 않게 할 수 있음

### 6.8 리포지토리 인터페이스 설계

Spring Data JPA는 JpaRepository를 기반으로 더욱 쉽게 데이터베이스를 사용할 수 있는 아키텍처를 제공함
스프링 부트로 JpaRepository를 상속하는 인터페이스를 생성하면 기존의 다양한 메서드를 손쉽게 활용할 수 있음

#### 6.8.1 리포지토리 인터페이스 생성

- 리포지토리(Repository)는 Spring Data JPA가 제공하는 인터페이스임
- 엔티티를 데이터베이스의 테이블과 구조를 생성하는데 사용했다면 리포지토리는 엔티티가 생성한 데이터베이스에 접근하는데 사용됨
  - 데이터베이스에 접근!!

### 6.9 DAO 설계

- Data Access Object
  - 데이터베이스 접근 로직 관리!!
- 데이터베이스에 접근하기 위한 로직을 관리하기 위한 객체임
- 비즈니스 로직의 동작 과정에서 데이터를 조작하는 기능은 DAO 객체가 수행함
  - 스프링 데이터 JPA에서 DAO의 개념은 리포지토리가 대체하고 있음

##### getById()

- 리포지토리에서 단건 조회

##### findById()

- 리포지토리에서 단건 조회

#### Update??

JPA에서 데이터의 값을 변경할 때는 다른 메서드와는 다른점이 있음

- JPA는 값을 갱신할 때 update라는 키워드를 사용하지 않음
- 영속성 컨텍스트를 활용해 값을 갱신하는데 find() 메서드를 통해 데이터베이스에서 값을 가져오면 가져온 객체가 영속성 컨텍스트에 추가됨
- 영속성 컨텍스트가 유지되는 상황에서 객체의 값을 변경하고 다시 save()를 실행하면 JPA에서는 더티 체크(Dirty Check)라고 하는 변경 감지를 수행함

### 6.10 DAO 연동을 위한 컨트롤러와 서비스 설계

- 클라이언트의 요청과 연결하려면 컨트롤러와 서비스를 생성해야 함

'컨트롤러 - 서비스 - DAO - 리포지토리

### 6.11 반복되는 코드의 작성을 생략하는 방법 - 롬복

- Lombok : 데이터(모델) 클래스를 생성할 때 반복적으로 사용하는 getter/setter 같은 메서드를 어노테이션으로 대체하는 기능을 제공하는 라이브러리임

롬복 장점

- 어노테이션 기반으로 코드를 자동 생성하므로 생산성이 높아짐
- 반복되는 코드를 생략할 수 있어 가독성이 좋아짐
- 롬복을 안다면 간단하게 코드를 유추할 수 있어 유지보수에 용이함

## 08. Spring Data JPA 활용

### 8.2 JPQL

- JPA Query Language
- JPA에서 사용할 수 있는 쿼리를 의미함
- JPQL의 문법은 SQL과 매우 비슷함
  - 차이점 : 매핑된 엔티티의 이름과 필드의 이름을 사용함

```JPQL
SELECT p FROM Product p WHERE p.number = ?1;
```

### 8.5 @Query 어노테이션 사용하기

- 튜닝된 쿼리를 사용하고자 할 때 직접 해당 데이터베이스의 특화된 SQL을 작성할 수 있음, 주로 튜닝된 쿼리를 사용하고자 할 때 직접 SQL을 작성함

[참고도서 - 스프링부트 핵심가이드]

#### 스프링이랑 스프링 부트 차이

- 스프링(Spring)은 자바 언어를 기반으로 한 오픈 소스 프레임워크로, 엔터프라이즈급 애플리케이션을 개발하기 위한 종합적인 솔루션을 제공함
- 스프링은 의존성 주입(Dependency Injection)과 관점 지향 프로그래밍(Aspect-Oriented Programming) 등의 기능을 제공하여 개발자가 코드를 더 쉽게 작성하고 관리할 수 있도록 도움

- 스프링 부트(Spring Boot)는 스프링 프레임워크의 하위 프로젝트로, 스프링 애플리케이션을 빠르고 쉽게 구축할 수 있도록 돕는 도구임
- 스프링 부트는 기본 설정을 자동으로 처리하여 개발자가 복잡한 설정을 할 필요가 없도록 해줌
- 이는 개발자가 빠르게 프로토타입을 만들고, 실제 애플리케이션을 더 신속하게 배포할 수 있도록 도와줌

- 스프링 부트는 내장된 서버를 제공하여 애플리케이션을 실행하고, 스프링 프레임워크와 호환되도록 설계되어 있음
- 또한 외부 라이브러리와의 통합을 용이하게 해주는 다양한 스타터(Starter) 패키지를 제공하여 개발자가 필요한 기능을 쉽게 추가할 수 있도록 함
- 이러한 특징들로 스프링 부트는 빠른 개발과 운영을 위한 이상적인 선택이 됨

#### 도메인이랑 Entity의 차이

1. **도메인(Domain):**
   - 도메인은 문제 영역 또는 비즈니스 도메인이라고도 함
   - 이는 소프트웨어가 해결하려는 문제 영역이나 해당 소프트웨어가 대상으로 하는 현실 세계의 영역을 의미함
   - 예를 들어, 은행 애플리케이션의 도메인은 계좌, 거래, 고객 등과 같은 개념을 포함함
     - 이러한 개념들은 소프트웨어 시스템이 해결하고자 하는 실제 비즈니스의 영역임
2. **엔티티(Entity):**
   - 엔티티는 도메인에 속하는 구체적인 사물이나 객체를 나타냄
   - 보통 데이터베이스나 소프트웨어 코드에서 식별될 수 있는 개별적인 개념을 의미함
   - 예를 들어, 은행 애플리케이션에서 계좌 엔티티는 실제 은행 계좌를 나타내며, 계좌 번호, 잔고 등의 속성을 가짐
   - 고객 엔티티는 은행의 고객을 나타내며, 이름, 주소 등의 속성을 가짐

- 요약 : 도메인은 소프트웨어가 다루는 문제 영역이고, 엔티티는 도메인에 속하는 구체적인 개념이나 객체를 나타냄. 도메인은 엔티티들의 집합체이며, 엔티티들은 도메인을 이루는 구성 요소임
