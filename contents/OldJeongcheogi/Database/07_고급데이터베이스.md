# 고급데이터베이스

### 트랜잭션 정의

- Transaction
- 데이터베이스의 상태를 변화시키는 논리적 연산의 집합

### 트랜잭션 특징 ACID

1. 원자성
   - Atomicity
   - 모두 반영되거나 아니면 전혀 반영되지 안아야 됨 (부분 실행 안됨)
2. 일관성
   - Consistency
   - 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있게 DB 상태로 변환
   - 시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후에 같아야 함
3. 독립성, 격리성
   - Isolation
   - 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때 또 다른 하나의 트랜잭션의 연산이 끼어들 수 없음
4. 영속성, 지속성
   - Durability
   - 트랜잭션의 결과는 영구적으로 반영

### 트랜잭션 연산

- COMMIT :

  - 한 작업의 논리적 단위가 성공적으로 끝났고, DB가 다시 일관된 상태에 있으며 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산

- ROLLBACK :
  - 트랜잭션의 실행이 실패하였음을 알리는 연산자로 트랜잭션이 수행한 결과를 원래의 상태로 원산 복귀시키는 연산

#### 회복의 정의

- 트랜잭션 수행도중 장애가 발생하여 데이터베이스가 손상 입었기에 손상되기 이전 상태로 복구하는 작업

#### 장애의 유형

1. 트랜잭션 장애
2. 시스템 장애
3. 미디어 장애

- 트랜잭션 장애가 데이터베이스에 손상을 줄 가능성이 가장 적은 장애

---

### 보안, 암호화

1. 개인키 암호화 알고리즘
   - 암호화키 = 복호화키
   - 동일한 키를 이용하는 방식
   - 보안수준이 낮음
   - 알고리즘이 단순하고 빠름
2. 공개키 암호화 알고리즘
   - 암호화키 != 복호화키
   - 서로 다른 키를 사용하는 비대칭 암호화 방식
   - 보안 수준이 높음
   - 속도가 느리고 알고리즘 복잡
   - 파일크기도 큼

- 보안과 무결성

  - 무결성은 권한이 있는 사용자로부터 DB를 보호하는 것
  - 보안은 권한이 없는 사용자로부터 DB를 보호하는 것

- 보안을 위한 사용자들의 권한 부여는 관리자의 정책에 의해 결정되어 짐

---

### 병행제어 정의

- 동시에 여러 개 수행할 때, 데이터베이스 일관성 유지를 위해 트랜잭션 간의 상호 작용을 제어

#### 병행제어 목적

1. DB 공유 최대화
2. DB 일관성 유지
3. 시스템 활용도 최대화
4. 사용자에 대한 응답시간 최소화

### 병행제어 기법

1. 로킹

   - 하나의 트랜잭션이 데이터를 액세스하는 동안 다른 트랜잭션이 그 데이터 항목을 액세스 할 수 없도록 하는 방법

2. 로킹 단위
   - 병행제어에서 한꺼번에 로킹 할 수 있는 단위
   - 로킹 단위가 크면 -> 로크수가 작다 -> 관리가 수월해지고 병행성 수준 낮음
   - 로킹 단위가 작으면 -> 로크수가 커짐 -> 관리자 복잡해지고 병행성 수준 높음

### 병행수행 허용시 발생하는 문제점

1. 갱신분실 : 2개 이상의 트랜잭션이 같은 자료를 갱신할 때 일부가 없어지는 현상
2. 비완료 의존성 : 하나의 트랜잭션이 실패한 후 다른 트랜잭션이 실패한 갱신 결과를 참조하는 현상
3. 불일치 : 원치 않는 자료를 이용하는 현상

---

### 분산데이터베이스 정의

- 컴퓨터 네트워크 상에 물리적으로 분산된 데이터베이스를 논리적으로 1개로 인식하는 기법

#### 분산데이터베이스 4대 목표

1. 위치 투명성
   - 사용자가 물리적으로 저장되어 있는 곳을 알 필요 없이 논리적인 입장에서 데이터가 모두 자신의 사이트에 있는 것 처럼 처리
2. 중복(복제) 투명성
   - 트랜잭션이 데이터의 중복 개수나 중복 사실을 모르고도 데이터 처리가 가능
3. 병행 투명성
   - 분산 데이터베이스와 관련된 다수의 트랜잭션들이 동시에 실현 되더라도 그 트랜잭션의 결과는 영향을 안 받음
4. 장애 투명성
   - 트랜잭션, DBMS, 네트워크, 컴퓨터 장애에도 불구하고 트래잭션을 정화하게 처리함

## 분산데이터베이스의 특징

1. 자료 공유가 용이
2. 시스템 성능 향상
3. 점증적 시스템 요량 확장 용이
4. **_설계가 어렵고, 소프트웨어 개발 비용 증가_**
5. 오류 발생 가능성 높음

참고 [기사퍼스트_권우석]
